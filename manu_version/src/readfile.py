#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Try to read the files generated byt the bic.

XXX Add more explanations.
"""

# imports
import os
import re
import glob
from collections import OrderedDict
import logging
logging.basicConfig(level=logging.INFO)

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import constants
pd.options.mode.chained_assignment = None
from pandas.tools.plotting import scatter_matrix, andrews_curves
from astropy.visualization import hist
from joblib import Memory, Parallel, delayed
from array import array
from outliers import smirnov_grubbs as grubbs
from constants import *


def generate_feature_vector(data,min,max,hist_bins,hist_labels):
    """Generate the MSD feature vector from the MSD data"""

    data[data<min] = min
    data[data>max] = max

    # Compute a normalized histogram
    hist, bins = np.histogram(data,bins=hist_bins)
    #plt.hist(hist, bins=bins, facecolor='m', alpha=0.75)
    #plt.show()
    
    hist = hist/float(hist.sum())
    
    # Build the features
    feat = OrderedDict( zip(hist_labels, hist))
    df = pd.DataFrame([feat])
    df = df.reindex_axis(feat.keys(), axis=1) #order seems eroneous
    return df


def freedman_bin_width(data, return_bins):
    data = np.asarray(data)
    if data.ndim != 1:
        raise ValueError("data should be one-dimensional")

    n = data.size
    if n < 4:
        raise ValueError("data should have more than three entries")

    v25, v75 = np.percentile(data, [25, 75])
    dx = 2 * (v75 - v25) / (n ** (1 / 3))

    if return_bins:
        dmin, dmax = data.min(), data.max()
        Nbins = max(1, np.ceil((dmax - dmin) / dx))
        bins = dmin + dx * np.arange(Nbins + 1)
        return dx, bins
    else:
        return dx


def freedman_diaconis(object_df,point_df):
    """Return the optimal histogram bin width using the Freedman-Diaconis rule"""

    #freedman for Dinst
    da_global,bins_global = freedman_bin_width(point_df['Dinst'], True)
    DINST_MIN=bins_global[0]
    DINST_MAX=bins_global[len(bins_global)-1]
    DINST_HISTOGRAM_BINS=bins_global
    DINST_HISTOGRAM_LABELS = ["HIST_DINST_%f" % _ for _ in DINST_HISTOGRAM_BINS[:-1]]

    #freedman for msd_0
    da_global,bins_global = freedman_bin_width(object_df['MSD_0'], True)
    MSD_MIN=bins_global[0]
    MSD_MAX=bins_global[len(bins_global)-1]
    MSD_HISTOGRAM_BINS=bins_global
    MSD_HISTOGRAM_LABELS = ["HIST_MSD_%f" % _ for _ in MSD_HISTOGRAM_BINS[:-1]]
    
    # freedman for diffusion coefficient
    da_global, bins_global = freedman_bin_width(object_df['Diffusion_Coefficient'], True)
    DIFF_MIN=bins_global[0]
    DIFF_MAX=bins_global[len(bins_global)-1]
    DIFF_HISTOGRAM_BINS=bins_global
    DIFF_HISTOGRAM_LABELS = ["DENSITY_MSD_%f" % _ for _ in DENSITY_HISTOGRAM_BINS[:-1]]
    
    return (DIFF_MIN, DIFF_MAX, DIFF_HISTOGRAM_BINS, DIFF_HISTOGRAM_LABELS, MSD_MIN,MSD_MAX,MSD_HISTOGRAM_BINS,MSD_HISTOGRAM_LABELS,DINST_MIN,DINST_MAX,DINST_HISTOGRAM_BINS,DINST_HISTOGRAM_LABELS) 

def generate_diffusion_coefficient_features_vector(density,DENSITY_MIN,DENSITY_MAX,DENSITY_HISTOGRAM_BINS,DENSITY_HISTOGRAM_LABELS):

    density.loc[density<DENSITY_MIN] = DENSITY_MIN
    density.loc[density>DENSITY_MAX] = DENSITY_MAX

    # Compute a normalized histogram
    hist, bins = np.histogram(density, 
                                       bins=DENSITY_HISTOGRAM_BINS)
    hist = hist/float(hist.sum())

    # Build the features
    feat = OrderedDict( zip(DENSITY_HISTOGRAM_LABELS, hist))
    df = pd.DataFrame([feat])
    df = df.reindex_axis(feat.keys(), axis=1) #order seems eroneous

    return df

def generate_dinst_feature_vector(dinst,DINST_MIN,DINST_MAX,DINST_HISTOGRAM_BINS,DINST_HISTOGRAM_LABELS):
    #print DINST_HISTOGRAM_BINS
    dinst.loc[dinst<DINST_MIN] = DINST_MIN
    dinst.loc[dinst>DINST_MAX] = DINST_MAX
    #print DINST_HISTOGRAM_BINS

    # Compute a normalized histogram
    hist, bins = np.histogram(dinst, bins=DINST_HISTOGRAM_BINS)
    hist = hist/float(hist.sum())

    # Build the features
    feat = OrderedDict( zip(DINST_HISTOGRAM_LABELS, hist))
    df = pd.DataFrame([feat])
    df = df.reindex_axis(feat.keys(), axis=1) #order seems eroneous

    return df
 
                   
def extract_wave_tracer_features(df): 

    df_columns = ['ImageNumber', 'total_movement']
    dataTab_noOutliers = pd.DataFrame()
    data_df = pd.DataFrame()
    global_df = pd.DataFrame()
    samples = vec = dfRes= []
    total_length=0

    if BINNING_TYPE=="freedman_std":
        for ROI,data in df.groupby('ImageNumber'):
            dataTab = []
            for ROI2,data2 in data.groupby('WaveTracerID'):
                dataTab.append(len(data2['WaveTracerID']))
            print ROI
            data4grubbs = pd.Series(dataTab)
            total_length+=len(data4grubbs.index)
            grubbsResult=grubbs.test(data4grubbs, alpha=0.05)
            vec = len(grubbsResult)*[ROI]
            dataTab_noOutliers = pd.DataFrame({'ImageNumber' : vec, 'total_movement' : grubbsResult.tolist()})
            data_df= data_df.append(dataTab_noOutliers, ignore_index=True)


        print "SIZE BEFORE GRUBBS : " + str(total_length)
        print "SIZE AFTER GRUBBS : "+str(len(data_df.index))
        print "TRAJECTORY REMOVED : "+str(total_length-len(data_df.index))
        print "TRAJECTORY Keeped : "+str((len(data_df.index)*100)/total_length)+"%"
        # print "MAX TRAJECTORY SIZE (afg): "+str(data_df['total_movement'].max())
        data_df['total_movement'].plot(kind='line')

        da_global,bins_global = freedman_bin_width(data_df['total_movement'], True)
        DINST_MIN=bins_global[0]
        DINST_MAX=bins_global[len(bins_global)-1]
        DINST_HISTOGRAM_BINS=bins_global
        DINST_HISTOGRAM_LABELS = ["HIST_DINST_%f" % _ for _ in DINST_HISTOGRAM_BINS[:-1]]
        print DINST_HISTOGRAM_LABELS

        for ROI, data in data_df.groupby('ImageNumber'):
            dinst_features = generate_feature_vector(data['total_movement'],DINST_MIN,DINST_MAX,DINST_HISTOGRAM_BINS,DINST_HISTOGRAM_LABELS)
            dinst_features['index'] = ROI
            dinst_features = dinst_features.set_index('index')
            samples.append(dinst_features)
        pd.concat(samples).to_csv(os.path.join(OUTPUT_DIR, "samplesWaveTracer.csv"),sep=",")

    return (pd.concat(samples),DINST_HISTOGRAM_LABELS)


def extract_dinst_features(df):
    samples = []
    DINST_MIN=10e-5
    DINST_MAX=2.5
    DINST_HISTOGRAM_BINS=np.linspace(DINST_MIN, DINST_MAX, num=20)
    DINST_HISTOGRAM_LABELS=["HIST_DINST_%f" % _ for _ in DINST_HISTOGRAM_BINS[:-1]]

    if BINNING_TYPE=="freedman_std":  
        da_global,bins_global = freedman_bin_width(df['Dinst_std'], True)
        DINST_MIN=bins_global[0]
        DINST_MAX=bins_global[len(bins_global)-1]
        DINST_HISTOGRAM_BINS=bins_global
        DINST_HISTOGRAM_LABELS = ["HIST_DINST_%f" % _ for _ in DINST_HISTOGRAM_BINS[:-1]]
        for ROI, data in df.groupby('ImageNumber'):
            #print data['Dinst_std']
            dinst_features = generate_dinst_feature_vector(data['Dinst_std'],DINST_MIN,DINST_MAX,DINST_HISTOGRAM_BINS,DINST_HISTOGRAM_LABELS)
            dinst_features['index'] = ROI
            dinst_features = dinst_features.set_index('index')
            samples.append(dinst_features)
    return (pd.concat(samples),DINST_HISTOGRAM_LABELS)



def extract_dinstL_features(df):
    samples = []
    DINST_MIN=10e-5
    DINST_MAX=2.5
    DINST_HISTOGRAM_BINS=np.linspace(DINST_MIN, DINST_MAX, num=20)
    DINST_HISTOGRAM_LABELS=["HIST_DINST_%f" % _ for _ in DINST_HISTOGRAM_BINS[:-1]]

    if BINNING_TYPE=="freedman_std":  
        da_global,bins_global = freedman_bin_width(df['DinstL_std'], True)
        DINST_MIN=bins_global[0]
        DINST_MAX=bins_global[len(bins_global)-1]
        DINST_HISTOGRAM_BINS=bins_global
        DINST_HISTOGRAM_LABELS = ["HIST_DINST_%f" % _ for _ in DINST_HISTOGRAM_BINS[:-1]]
        for ROI, data in df.groupby('ImageNumber'):
            #print data['Dinst_std']
            dinst_features = generate_dinst_feature_vector(data['DinstL_std'],DINST_MIN,DINST_MAX,DINST_HISTOGRAM_BINS,DINST_HISTOGRAM_LABELS)
            dinst_features['index'] = ROI
            dinst_features = dinst_features.set_index('index')
            samples.append(dinst_features)

    return (pd.concat(samples),DINST_HISTOGRAM_LABELS)



##normalisation
def preprocess_object_data(df):

    grouped=df.groupby('ImageNumber')
    zscore = lambda x: (x - x.mean()) / x.std()

    transformed_DC = grouped['Diffusion_Coefficient'].transform(zscore)  
    transformed_MSD = grouped['MSD_0'].transform(zscore)

    DC_std = pd.DataFrame(transformed_DC)
    MSD_std = pd.DataFrame(transformed_MSD)

    DC_std.columns = ['Diffusion_Coefficient_std']
    MSD_std.columns = ['MSD_0_std']
    df=pd.concat([df, DC_std], axis=1,verify_integrity=False)
    df=pd.concat([df, MSD_std], axis=1,verify_integrity=False)
    return df



def preprocess_data(df, colName):
    grouped=df.groupby('ImageNumber')
    zscore = lambda x: (x - x.mean()) / x.std()
    transformed_data = grouped[colName].transform(zscore)  
    stdTab = pd.DataFrame(transformed_data)
    stdColName=colName+"_std"
    stdTab.columns = [stdColName]
    df=pd.concat([df, stdTab], axis=1,verify_integrity=False)
    return df



def compute_max_bin_values(object_df, point_df):
    max_diff_coeff_global=[]
    max_diff_coeff_len=0
    max_MSD_global=[]
    max_MSD_len=0

    for ROI, data in object_df.groupby('ImageNumber'):
        #Compute Freedman-Diaconis algorithm for MSD_0
        da_global,bins_global = freedman_bin_width(data['Diffusion_Coefficient'], True)
        #print len(bins_global)
        if len(bins_global) > max_diff_coeff_len:
            max_diff_coeff_len=len(bins_global)
            max_diff_coeff_global=[]
            max_diff_coeff_global.append(bins_global)

        #Compute Freedman-Diaconis algorithm for diffusion coefficient
        da_global,bins_global = freedman_bin_width(data['MSD_0'], True)
        #print len(bins_global)
        if len(bins_global) > max_MSD_len:
            max_MSD_len=len(bins_global)
            max_MSD_global=[]

            max_MSD_global.append(bins_global)

    MSD_MIN=max_MSD_global[0][0]
    MSD_MAX=max_MSD_global[0][max_MSD_len-1]
    MSD_HISTOGRAM_BINS=max_MSD_global[0]
    #print MSD_HISTOGRAM_BINS
    MSD_HISTOGRAM_LABELS = ["HIST_MSD_%f" % _ for _ in MSD_HISTOGRAM_BINS[:-1]]

    DENSITY_MIN=max_diff_coeff_global[0][0]
    DENSITY_MAX=max_diff_coeff_global[0][max_diff_coeff_len-1]
    DENSITY_HISTOGRAM_BINS=max_diff_coeff_global[0]
    #print DENSITY_HISTOGRAM_BINS
    DENSITY_HISTOGRAM_LABELS = ["HIST_DENSITY_%f" % _ for _ in DENSITY_HISTOGRAM_BINS[:-1]]
    
    
    if CLASSIFICATION_MODE=='unsupervised':
        max_dinst_global=[]
        max_dinst_len=0
        for ROI, data in point_df.groupby('ImageNumber'):
            #Compute Freedman-Diaconis algorithm for MSD_0
            da_global,bins_global = freedman_bin_width(data['Dinst'], True)

            if len(bins_global) > max_dinst_len:
                max_dinst_len=len(bins_global)
                max_dinst_global=[]                
                max_dinst_global.append(bins_global)

        DINST_MIN=max_dinst_global[0][0]
        DINST_MAX=max_dinst_global[0][max_dinst_len-1]
        DINST_HISTOGRAM_BINS=max_dinst_global[0]
        DINST_HISTOGRAM_LABELS = ["HIST_DINST_%f" % _ for _ in DINST_HISTOGRAM_BINS[:-1]]
    else:
        #Here we fixed the bin size cause there is no dinst data for labeled datasets
        DINST_MIN=10e-5
        DINST_MAX=2.5
        DINST_HISTOGRAM_BINS=np.linspace(DINST_MIN, DINST_MAX, num=20)
        DINST_HISTOGRAM_LABELS=["HIST_DINST_%f" % _ for _ in DINST_HISTOGRAM_BINS[:-1]]         
    
    return (DENSITY_MIN,DENSITY_MAX,DENSITY_HISTOGRAM_BINS,DENSITY_HISTOGRAM_LABELS,MSD_MIN,MSD_MAX,MSD_HISTOGRAM_BINS,MSD_HISTOGRAM_LABELS,DINST_MIN,DINST_MAX,DINST_HISTOGRAM_BINS,DINST_HISTOGRAM_LABELS)

def extract_features_bin_max(object_df, point_df):
    samples = []
    #features_list=('MSD_0','Diffusion_Coefficient')
    #counter=0
        
    DENSITY_MIN,DENSITY_MAX,DENSITY_HISTOGRAM_BINS,DENSITY_HISTOGRAM_LABELS,MSD_MIN,MSD_MAX,MSD_HISTOGRAM_BINS,MSD_HISTOGRAM_LABELS,DINST_MIN,DINST_MAX,DINST_HISTOGRAM_BINS,DINST_HISTOGRAM_LABELS=compute_max_bin_values(object_df,point_df)
        
    
    for ROI, data in object_df.groupby('ImageNumber'):
        
        # XXX Generate vector of features
        msd_features = generate_feature_vector(data['MSD_0'],MSD_MIN,MSD_MAX,MSD_HISTOGRAM_BINS,MSD_HISTOGRAM_LABELS)      
        diffusion_features = generate_diffusion_coefficient_features_vector(data['Diffusion_Coefficient'],DENSITY_MIN,DENSITY_MAX,DENSITY_HISTOGRAM_BINS,DENSITY_HISTOGRAM_LABELS)
        
        # XXX Merge the set of features
        all_feat = pd.concat([diffusion_features, msd_features], axis=1,verify_integrity=False)
        all_feat['index'] = ROI
        all_feat = all_feat.set_index('index')
        samples.append(all_feat)
    samples = pd.concat(samples)    
        
    sample_dinst=[]    
    for ROI, data in point_df.groupby('ImageNumber'):
        
        dinst_features = generate_dinst_feature_vector(data['Dinst'],DINST_MIN,DINST_MAX,DINST_HISTOGRAM_BINS,DINST_HISTOGRAM_LABELS)
        dinst_features['index'] = ROI
        dinst_features = dinst_features.set_index('index')
        sample_dinst.append(dinst_features)  
                
    sample_dinst=pd.concat(sample_dinst)
    
    
    return (pd.concat([samples, sample_dinst], axis=1,verify_integrity=False),DENSITY_HISTOGRAM_LABELS,MSD_HISTOGRAM_LABELS,DINST_HISTOGRAM_LABELS)


def extract_features_bin_fixed(object_df,point_df):
    samples = []
    #features_list=('MSD_0','Diffusion_Coefficient')
    #counter=0

    DENSITY_MAX = 10e1
    DENSITY_MIN = 10e-5
    DENSITY_HISTOGRAM_BINS = np.logspace(-4, 1, num=20) # BINS to compute the density histogram
    DENSITY_HISTOGRAM_LABELS = ["HIST_DENSITY_%f" % _ for _ in DENSITY_HISTOGRAM_BINS[:-1]]

    MSD_MAX = 0.5
    MSD_MIN = -0.5
    MSD_HISTOGRAM_BINS = np.linspace(MSD_MIN, MSD_MAX, num=20)
    MSD_HISTOGRAM_LABELS = ["HIST_MSD_%f" % _ for _ in MSD_HISTOGRAM_BINS[:-1]]
    
    DINST_MIN=10e-5
    DINST_MAX=2.5
    DINST_HISTOGRAM_BINS=np.linspace(DINST_MIN, DINST_MAX, num=20)
    DINST_HISTOGRAM_LABELS=["HIST_DINST_%f" % _ for _ in DINST_HISTOGRAM_BINS[:-1]] 
    
    for ROI, data in object_df.groupby('ImageNumber'):
        
        # XXX Generate vector of features
        msd_features = generate_feature_vector(data['MSD_0'],MSD_MIN,MSD_MAX,MSD_HISTOGRAM_BINS,MSD_HISTOGRAM_LABELS)      
        diffusion_features = generate_diffusion_coefficient_features_vector(data['Diffusion_Coefficient'],DENSITY_MIN,DENSITY_MAX,DENSITY_HISTOGRAM_BINS,DENSITY_HISTOGRAM_LABELS)

        # XXX Merge the set of features
        all_feat = pd.concat([diffusion_features, msd_features], axis=1,verify_integrity=False)
        all_feat['index'] = ROI
        all_feat = all_feat.set_index('index')
        samples.append(all_feat)
    samples = pd.concat(samples)
    
    
    if CLASSIFICATION_MODE=='unsupervised':
        sample_dinst=[]    
        for ROI, data in point_df.groupby('ImageNumber'):
            dinst_features = generate_dinst_feature_vector(data['Dinst'],DINST_MIN,DINST_MAX,DINST_HISTOGRAM_BINS,DINST_HISTOGRAM_LABELS)
            dinst_features['index'] = ROI
            dinst_features = dinst_features.set_index('index')
            sample_dinst.append(dinst_features)  

        sample_dinst=pd.concat(sample_dinst)
        return (pd.concat([samples, sample_dinst], axis=1,verify_integrity=False),DENSITY_HISTOGRAM_LABELS,MSD_HISTOGRAM_LABELS,DINST_HISTOGRAM_LABELS)
    else:
        return (samples,DENSITY_HISTOGRAM_LABELS,MSD_HISTOGRAM_LABELS,DINST_HISTOGRAM_LABELS)


    #fig=plt.figure()
    #fig.savefig('/Users/benjamindartigues/super_class_test/src/histo.pdf',dpi=fig.dpi)
    #plt.close(fig)
    #print "samples after groupby in extract features"
    #print pd.concat(samples)

    #return (pd.concat(samples),DENSITY_HISTOGRAM_LABELS,MSD_HISTOGRAM_LABELS)
def extract_features_bin_std(df):
    """Extract the feature vector of each ROI (ImageNumber? or slot).
    This time we do not have any information on the number of time a particle is visible"""
    samples = []
    #features_list=('MSD_0','Diffusion_Coefficient')
    #counter=0
    
    if BINNING_TYPE=="freedman_max":
        max_diff_coeff_global=[]
        max_diff_coeff_len=0
        max_MSD_global=[]
        max_MSD_len=0


        for ROI, data in df.groupby('ImageNumber'):
            #Compute Freedman-Diaconis algorithm for MSD_0
            print "image number:" + str(ROI)
            da_global,bins_global = freedman_bin_width(data['Diffusion_Coefficient_std'], True)
            print bins_global
            print "nombre de bin for Diffusion_Coefficient_std:" + str(len(bins_global))
            
            if len(bins_global) > max_diff_coeff_len:
                max_diff_coeff_len=len(bins_global)
                max_diff_coeff_global=[]
                max_diff_coeff_global.append(bins_global)
                print "nouvelle taille max pour Diffusion_Coefficient_std:"
                print "###################################################"
                print bins_global
                print "###################################################"


            #Compute Freedman-Diaconis algorithm for diffusion coefficient
            da_global,bins_global = freedman_bin_width(data['MSD_0_std'], True)
            print bins_global
            print "nombre de bin for MSD_0_std:" + str(len(bins_global))
            
            if len(bins_global) > max_MSD_len:
                max_MSD_len=len(bins_global)
                max_MSD_global=[]

                max_MSD_global.append(bins_global)

        MSD_MIN=max_MSD_global[0][0]
        MSD_MAX=max_MSD_global[0][max_MSD_len-1]
        MSD_HISTOGRAM_BINS=max_MSD_global[0]
        #print MSD_HISTOGRAM_BINS
        MSD_HISTOGRAM_LABELS = ["HIST_MSD_%f" % _ for _ in MSD_HISTOGRAM_BINS[:-1]]

        DENSITY_MIN=max_diff_coeff_global[0][0]
        DENSITY_MAX=max_diff_coeff_global[0][max_diff_coeff_len-1]
        DENSITY_HISTOGRAM_BINS=max_diff_coeff_global[0]
        #print DENSITY_HISTOGRAM_BINS
        DENSITY_HISTOGRAM_LABELS = ["HIST_DENSITY_%f" % _ for _ in DENSITY_HISTOGRAM_BINS[:-1]]


    if BINNING_TYPE=="freedman_std": 
        
        da_global,bins_global = freedman_bin_width(df['Diffusion_Coefficient_std'], True)
        DENSITY_MIN=bins_global[0]
        DENSITY_MAX=bins_global[len(bins_global)-1]
        DENSITY_HISTOGRAM_BINS=bins_global
        #print DENSITY_HISTOGRAM_BINS
        DENSITY_HISTOGRAM_LABELS = ["DENSITY_MSD_%f" % _ for _ in DENSITY_HISTOGRAM_BINS[:-1]]
        
        da_global,bins_global = freedman_bin_width(df['MSD_0_std'], True)
        MSD_MIN=bins_global[0]
        MSD_MAX=bins_global[len(bins_global)-1]
        MSD_HISTOGRAM_BINS=bins_global
        #print DENSITY_HISTOGRAM_BINS
        MSD_HISTOGRAM_LABELS = ["HIST_MSD_%f" % _ for _ in MSD_HISTOGRAM_BINS[:-1]]
        
    
    for ROI, data in df.groupby('ImageNumber'):
        
        # XXX Generate vector of features
        
        msd_features = generate_feature_vector(data['MSD_0_std'],MSD_MIN,MSD_MAX,MSD_HISTOGRAM_BINS,MSD_HISTOGRAM_LABELS)      
        diffusion_features = generate_diffusion_coefficient_features_vector(data['Diffusion_Coefficient_std'],DENSITY_MIN,DENSITY_MAX,DENSITY_HISTOGRAM_BINS,DENSITY_HISTOGRAM_LABELS)
        
        # XXX Merge the set of features
        all_feat = pd.concat([diffusion_features, msd_features], axis=1,verify_integrity=False)
        all_feat['index'] = ROI
        all_feat = all_feat.set_index('index')
        samples.append(all_feat)


    return (pd.concat(samples),DENSITY_HISTOGRAM_LABELS,MSD_HISTOGRAM_LABELS)


def extract_features(df,DENSITY_MIN,DENSITY_MAX,DENSITY_HISTOGRAM_BINS,DENSITY_HISTOGRAM_LABELS,MSD_MIN,MSD_MAX,MSD_HISTOGRAM_BINS,MSD_HISTOGRAM_LABELS):
	"""Extract the feature vector of each ROI (ImageNumber? or slot).
	This time we do not have any information on the number of time a particle is visible"""
	samples = []
	features_list=('MSD_0','Diffusion_Coefficient')
        counter=0
        #print df
        #print "samples before groupby in extract features"
        #print df 
	for ROI, data in df.groupby('ImageNumber'):
            # XXX Generate vector of features
            msd_features = generate_feature_vector(data['MSD_0'],MSD_MIN,MSD_MAX,MSD_HISTOGRAM_BINS,MSD_HISTOGRAM_LABELS)

            diffusion_features = generate_diffusion_coefficient_features_vector(data['Diffusion_Coefficient'],DENSITY_MIN,DENSITY_MAX,DENSITY_HISTOGRAM_BINS,DENSITY_HISTOGRAM_LABELS)

            all_feat = pd.concat([diffusion_features, msd_features], axis=1,verify_integrity=False)
            all_feat['index'] = ROI
            all_feat = all_feat.set_index('index')
            samples.append(all_feat)


            #histFrdDiac, binsFrdDiac = np.histogram(data['MSD_0'], bins=MSD_HISTOGRAM_BINS)
            #histFrdDiac = histFrdDiac /float(histFrdDiac.sum())
            #plt.hist(histFrdDiac, binsFrdDiac)
            #plt.show()
             
        #fig=plt.figure()
        #fig.savefig('/Users/benjamindartigues/super_class_test/src/histo.pdf',dpi=fig.dpi)
        #plt.close(fig)
        print "samples after groupby in extract features"
        #print pd.concat(samples)
        
	return pd.concat(samples)

def extract_features_of_result(df):
	"""Extract the feature vector of each ROI (ImageNumber? or slot).
	This time we do not have any information on the number of time a particle is visible"""
	samples = []

	for ImageNumber, data in df.groupby('ImageNumber'):
		print "Image Number : "
		print ImageNumber
		print "Data : "
		print data['NbrDinstinTracks']
		nbdata =data['NbrDinstinTracks']
		
		hist, bins = np.histogram(nbdata, bins=bins)
		#hist = hist/float(hist.sum())
		plt.hist(hist, bins=bins, facecolor='m', alpha=0.75)
		plt.xlabel( 'Bins' )
		plt.ylabel( 'NbrDinstinTracks' )
		plt.show()



def associate_pit_to_samples(features, img_df):
	"""Compute the pit of each sample and returns an array of pit"""

	# Builf the Look Up Table from an image to a pit
	pits = img_df['well']
	imgs = img_df['ImageNumber']
        #print pits
        #print imgs

	LUT = dict(zip(imgs, pits))
        #print LUT
	# Get the corresponding pit
	# (XXX as an array and not a DataFrame in order to avoid index issues)
	#

	return features.reset_index()['index'].apply(lambda idx: LUT[idx]).values



# metadata
__author__ = 'Romain Giot'
__copyright__ = 'Copyright 2013, LaBRI'
__credits__ = ['Romain Giot']
__licence__ = 'GPL'
__version__ = '0.1'
__maintainer__ = 'Romain Giot'
__email__ = 'romain.giot@u-bordeaux1.fr'
__status__ = 'Prototype'

